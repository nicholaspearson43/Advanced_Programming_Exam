# Report

## Node
`Node` is a templated struct. Each node has four members: `elem` which is the data stored in the node, for which a template is placed for its key and its value. 
There are two unique pointers to the `left` and `right` children and a raw pointer to the `parent` node.
The pointer to `left` and `right` are set as `nullptr` if the node has no children. 
The implementation takes care of defining some custom constructors that will be exploited in the `bst` class and a copy constructor. The default destructor is used. 


## Iterator
`Iterator` is a templated class. It implements the forward iterator for the `bst` class. The first templated type is necessary to define a pointer 
to the current node while the second templated type is the datatype of the pair stored in the node. 
The pre-increment and post-increment are defined to be able to move from one node to the subsequent one in the `bst` with ease. 

## Binary Search Tree
The `bst` class is templated on the three typenames: `K`, `V` and `OP`. The first two define the datatypes of the element of the pair inserted in each node (the first one referrs to 
the key datatype while the second to the value stored in the pair) while `OP` is a comparison operator, used mainly in the construction of the tree. It is set by default to `std::less<K>`.

The bst has the following private members: `root` which is a unique pointer to the root node , `size` which is a `std::size_t` variable storing the number of nodes in the tree and `cmp` which is the comparison operator.
The first two members can be read with the public functions `get_root()` (which returns the pointer to the root node) and `get_size()`. 

The following public functions were implemented:
#### Insert
```
std::pair<iterator, bool> insert(const pair_type& x);
std::pair<iterator, bool> insert(pair_type &&&x);
```
Are used to insert a new node. They return a pair of an iterator to the new node and a boolean which is set to true is a new node was inserted, false if the key was already present. 
The tree is scanned based on the value of the new key and it is traversed in a binary fashion. If a new node can be allocated, it becomes the left or right child of another node, which is set as its parent. 
If the tree was previously empty the first node inserted is set as the root node of the tree. 
The auxialiary function `_insert` is used for both cases.

#### Emplace
```
template <class... Types>
std::pair<iterator, bool> emplace(Types&&...args)
```
It inserted a new node in-place, using a variadic template. 

#### Clear
```
void clear()
```
Empties the tree. The pointer to the root (which is a unique pointer) is reset and all the nodes are realeased from memory. The `size` of the tree is set to 0. 

#### Begin
```
iterator begin();
const_iterator begin() const;
const_iterator cbegin() const;
```
Returns an iterator or const_iterator to the left most node of the tree, first one in the traversed tree. They are constructed with the auxiliary function `smallest()` 
which returns a pointer to the node with the smallest key. 

#### End
```
iterator end();
const_iterator end() const;
const_iterator cend() const;
```
Returns an iterator or const_iterator to one past the last element of the tree: they are set as iterators to `nullptr`. 

#### Find
```
iterator find(const K& x);
const_iterator find(const K& x) const;
```
They return an iterator to the node associated to the key, if present in the tree. They call the auxiliary function `_find` which returns a pointer to the node: it performs
a binary seach on the tree looking for the key. 


#### Balance
```
void balance();
```
It balances the tree. The pairs stores in the nodes of the tree are stored in a `std::vector<pair_type>` from which the elements are added to the tree one at the time. The median node in the vector is the new root of the tree.

#### Subscripting operator
```
V& operator[](const K& x);
V& operator[](K&& x);
```
Returns a reference to the value mapped to the key. If the key was not present in the tree, a new node is inserted and a default value for the key is used. 

#### Put-to operator
```
friend
std::ostream& operator<<(std::ostream& os, const bst& x);
```
The put-to operator prints all the keys and associated values in the tree, traversed in order. 

#### Copy and move semantics
The move semantic is the one generated by default by the compiler while the copy semantics was implemented by hand to perform a deep copy. 
The recursive auxiliary function `_copy` is used. 

#### Erase
```
void erase(const K& x);
```
Deletes a node from the tree. If the node is a leaf, it is simply removed. If it has only one child, the child is connected to the parent and the node is removed. 
In the case in which the node has a left and right child, the node `destination` is defined as the left most node in the subtree rooted on the right child. 
The subtree rooted on the left child is linked to the `destination` and the node is removed. `erase` also takes care of reassigning the value of the root in the case in which it coincides with the node to be removed. 


